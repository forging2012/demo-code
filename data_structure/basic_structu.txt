## 数据结构的学习
## 2018.3.6

一、学习网址
	1、严长生
		http://data.bianchegn.net/view/8.html
		http://data.biancheng.net/view/13.html



逻辑结构的类型：
	集合结构:元素之间的关系比较松散
	线性结构:元素的关系是一对一的，都挨着的，比如数组
	树形结构:元素的关系是一对多的关系，比如二叉树什么的
	图形结构:元素的关系是多对多的。(容易想到有向图，无向图)
			但是在程序里面，好像我不知道在哪里可以用到。

	对于线性结构，通常来说就是数组了，查找快，增删慢
	对于树形结构，我想到的就是红黑树，二叉树，堆排序(没有试验过，但是感觉和树形结构有关系)
	对于图形结构，目前想不到哪里会用到的
物理结构的类型：
	顺序存储：是把数据元素存放在连续的存储单元中。数据元素，一个接一个。查询快，增删慢。
	链式存储：位置随意，考指针来记录下一个元素的位置。增删快。查询慢
	
好的算法的特征：
	正确性：这个算法有正确的结果
	可读性：不仅自己可以看懂，别人也可以看懂
	健壮性：感觉就是容错，这个算法对于错误输入会怎么处理
	高效率：同一个问题，有多个算法，每个消耗的时间不一样，时间最短的效率最高
	低存储：占用较少的存储空间,比如求1到100和求1到100万的，占用内存就不一样。
	
算法效率的度量方法

事后统计方法
	必须一句算法事先编写好测试程序
	时间的比较依赖计算机硬件和软件等环境因素(对外界环境依赖比较大)
	算法的测试数据设计比较困难(对于测试数据的量不容易把握)
事前估算方法
	通过算法时间复杂度来估算算法时间效率
	某个算法，随着n的增大,它会越来越优于另一算法，或者越来越差于另一算法。这个就是事前估算法的理论依据。
	
函数的渐进增长：	
	给定两个函数f(n)和g(n)，如果存在一个整数N,使得对于所有的n>N,
f(n)总是比g(n)大,那么f(n)的增长渐进快于g(n)

判断一个算法的效率时,函数的常数和其他次要项常常可以忽略,更应该关注主项(最高阶项)的阶数
	
	
　
算法的时间复杂度
	1、定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。 
		也就是说时间复杂度是个根据代码算出来的.
	2、分类
		常数阶O(1)
		线性阶O(n)
	
树

1、节点类型
	父节点、子节点、兄弟节点、根节点、叶子节点
	根节点的判断依据:如果一个节点没有父节点,那么这个节点就是整棵树的跟节点。
	叶子节点：这个节点没有任何子节点,那么这个节点就是叶子节点
	单个节点也是树
	树的定义：由根节点和若干子树构成
2、相关概念
	节点的度:一个节点拥有的子树的个数
	树的度:树的度就是最大的节点的度
	节点的层次:根节点在第一层,一棵树的深度就是树中节点所在的最大层数(也就是节点的层数)。
	有序树和无序树：
3、树的表示方法
	最常用的表示方法是使用广义表的方式。图 1（A）用广义表表示为：
		(A , ( B ( E ( K , L ) , F ) , C ( G ) , D ( H ( M ) , I , J ) ) )
4、满二叉树、完全二叉树

	type Tree struct{

		left *Tree
		right *Tree
		data interface{}
	}
5、二叉树的遍历(遍历的顺序取决于跟几点的位置)
	前序遍历(先序遍历)：根--->左子树--->右子树
	中序遍历：左子树--->根--->右子树
	后续遍历：右子树--->左子树--->根
	对于二叉树的操作,它和递归就是仅仅关联在一起的,包括添加、删除一个节点、获取最值和全部数据。
	递归思想的底层实现,实际上是栈的数据结构,所以，对于二叉树遍历的操作也可以使用非递归的算法实现。

	
数组

1、数组和线性表的关系
	
	数组：数组作为一种数据类型，作用是将类型相同的数据存储在一整块内存中，
		 数组中存储的数据之间没有任何逻辑关系，谁也不认识谁。
	顺序表:作为线性表的存储结构，存储的这些数据元素在物理存储结构上相邻的同时，
	在逻辑结构上也相邻，每个数据元素都清楚地知道紧挨着它的前边的元素和后边的元素。
		关系:数组来存储的线性表是顺序表。
	1.2、数组的顺序存储结构
		数组在存储时有两种存储方式：
			以列序为主(先列后行)
			以行序为主(先行后列)
	1.3、数组中调取数据元素的方式
		在n维数组中调取数据元素,需要知道一下几个因素:
		1、数组的起始位置
		2、被调取元素的具体位置
		3、数组中单个数据元素占用的内存空间
2、矩阵

对称矩阵：如果n阶矩阵中的元素满足： aij=aji(i为行标,j为列标)，就称这个矩阵为对称矩阵。

	若将对称矩阵压缩存储在一维数组 S[k] 中，矩阵中数据元素在数组中存储的位置和所在的行标（用 i 表示）和列标（用 j 表示）有关。
	存储下三角区域的数据元素：
		k=i*(i-1)/2+j-1
	存储卡上三角区域的数据元素:
		k=j*(j-1)/2+i-1
上下三角矩阵
	上三角矩阵是指主对角线下方的元素（不包括主对角线上的）都是常数C（包括数值 0 ）
	下三角矩阵是指主对角线上方的元素都是常数C。
稀疏矩阵
	矩阵中只含有少量的非 0 元素
	
矩阵压缩存储的方式
矩阵压缩存储的方式有 3 种，分别为：三元组顺序表、行逻辑链接的顺序表和十字链表。	
	
	
	
	
type Node struct{
	data interface{}
	next *Node
	
}

type Stack struct{
	
	top *Node // 头指针
	count int // 堆栈的长度
}

栈
	1、定义：栈是线性表的一种特殊结构,只能从表的固定一端对数据进行插入和删除操作。
		在栈中可以对其操作的那一端称为"栈顶",被封死的那一端称为“栈底”
	2、栈中操作元素的方式：入栈和出栈
	3、栈的溢出
		上溢：在栈已经存满数据的情况下,如果继续向栈中存入数据,栈存储就会出错
		下溢：在栈内为空的情况下,如果继续对栈进行取数据操作,就会出错。
	4、分类
		顺序栈：底层用数组来实现
		链栈：用链表来实现
			链栈一般不需要创建头结点,头结点会增加程序的复杂性,只需要一个头指针就可以了
	
队列：
	1、队列是线性表的一种，在操作元素的时候，有自己的规则。使用队列存取数据元素时,数据元素只能从表的一端进入队列,则称进入队列的一端为“队尾”
		出队列的一端为“对头”。队列符合先进先出的规则,也就是陆陆续续从队列尾部进入，然后从队首出去。
	2、存储分类
		顺序存储(数组)和链式存储(链表)
	3、链式存储实现
		包括两个指针域和一个数据域
		type queue struct{
			head *node // 头指针
			tail *node // 尾指针
			count int  // 队列中元素的数量
		}
		
		type node struct{
			data interface{} // 保存当前节点的数据
			next *node // 指向下一个节点
		}
	4、使用队列应该注意：避免“野指针”的出现
		当队列中最后一个数据元素被删除时,不能认为和尾指针没有任何关系。
		如果这是个队列只有一个元素,当它被删除的时候,尾指针指向的内存空间已经被释放,这时候需要对尾指针进行重新定义。
		




线性表特点：
	1、存储的数据结构相同
	2、各个元素的相对位置已经固定(相对位置:也就是各个数据元素在逻辑结构上的前后顺序)
	3、分类：
		顺序结构：数据元素在内存中集中存储,采用顺序表示结构
		链式结构：数据元素在内存中散列存储,采用链式表示结构
		
		
		顺序结构：数组、切片。
		链式结构:map、自己设计的数据结构：比如程序中用到的队列。

		顺序表的实现使用的数组。顺序表查询快、增删慢
	4、链表
		4.1、线性表的链式存储结构生成的表称作"链表"
		4.2、链表中数据元素(节点)的构成
			数据域：这个节点包含的信息
			指针域：指向下一个节点的指针
		4.3、链表分类
			单向链表、双向链表
		4.4、链表的几个小概念吧
			头结点：
			首元节点：链表中第一个元素所在的位置，它是头结点后边的第一个节点
			头指针：永远指向链表中第一个节点的位置
		4.5、对链表进行操作
			node1--->node2--->node3--->node4
			插入节点
				向链表插入新节点在(node2和node3之间)新节点node5
					node5保存node3的地址(将保存在node2中下一个节点的位置给node5)
					node2保存node5的地址(取出node2节点的位置,然后把它赋值给node2)
			删除节点
				比如现在删除node3
					(将node3节点的位置临时备份一下)
					node2保存node4节点的位置(将保存在node3中node4节点的位置赋值给node2)
					去掉node3
		4.6、线性表和链性表的比较
			链式存储添加或者删除一个元素很容易，但是查询慢
			线性存储查询快，增删慢
	5、静态链表
			静态链表使用数组这一个数据类型预先申请足够大的内存空间。
		5.1、逻辑结构上相邻的数据元素，存储在制定的一块内存空间中,数据元素值允许在这块内存空间中随机存放，这样的存储结构就是静态链表。
		5.2、静态链表和动态链表的区别
			静态链表限制了数据元素存放的位置范围
			动态链表是整个内存空间
		5.3、静态链表的空间重复利用
			在静态链表中，提前将所有未使用的节点链成一个备用链表。在需要对链表进行操作时,从备用链表中拿过来一个节点使用。
			在删除节点时,删除的同时链接到备用链表上(也就是把删除节点的信息添加到备用链表上)
		5.4、链表中节点的构成
			数据域和游标(游标：存放的是下一个节点在数组中的位置下标)
		5.5、静态链表的特点
			静态链表综合了顺序链表和动态链表的有点：使用数组来存储数据元素,便于做查找遍历操作。
			同时在数中节点了动态链表的特点，在链表中插入或者删除节点时只需要更改相关节点的游标，不需要移动大量元素。
	6、双向链表
		6.1、双向链表：在单向链表的基础上,给每个节点额外配备一个指针变量,用于指向每隔节点的直接前驱节点,这就是双向链表
		6.2、双向链表的构成
			双向链表中有两个指针域和一个数据域。一个指向直接前趋，之歌指向直接后继。
		链表中第一个节点的前趋节点为nil,最后一个节点的后继节点为nil。
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			