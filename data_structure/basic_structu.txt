## 数据结构的学习
## 2018.3.6

一、学习网址
	1、严长生
		http://data.bianchegn.net/view/8.html
		http://data.biancheng.net/view/13.html



逻辑结构的类型：
	集合结构:元素之间的关系比较松散
	线性结构:元素的关系是一对一的，都挨着的，比如数组
	树形结构:元素的关系是一对多的关系，比如二叉树什么的
	图形结构:元素的关系是多对多的。(容易想到有向图，无向图)
			但是在程序里面，好像我不知道在哪里可以用到。

	对于线性结构，通常来说就是数组了，查找快，增删慢
	对于树形结构，我想到的就是红黑树，二叉树，堆排序(没有试验过，但是感觉和树形结构有关系)
	对于图形结构，目前想不到哪里会用到的
物理结构的类型：
	顺序存储：是把数据元素存放在连续的存储单元中。数据元素，一个接一个。查询快，增删慢。
	链式存储：位置随意，考指针来记录下一个元素的位置。增删快。查询慢
	
好的算法的特征：
	正确性：这个算法有正确的结果
	可读性：不仅自己可以看懂，别人也可以看懂
	健壮性：感觉就是容错，这个算法对于错误输入会怎么处理
	高效率：同一个问题，有多个算法，每个消耗的时间不一样，时间最短的效率最高
	低存储：占用较少的存储空间,比如求1到100和求1到100万的，占用内存就不一样。
	
算法效率的度量方法

事后统计方法
	必须一句算法事先编写好测试程序
	时间的比较依赖计算机硬件和软件等环境因素(对外界环境依赖比较大)
	算法的测试数据设计比较困难(对于测试数据的量不容易把握)
事前估算方法
	通过算法时间复杂度来估算算法时间效率
	某个算法，随着n的增大,它会越来越优于另一算法，或者越来越差于另一算法。这个就是事前估算法的理论依据。
	
函数的渐进增长：	
	给定两个函数f(n)和g(n)，如果存在一个整数N,使得对于所有的n>N,
f(n)总是比g(n)大,那么f(n)的增长渐进快于g(n)

判断一个算法的效率时,函数的常数和其他次要项常常可以忽略,更应该关注主项(最高阶项)的阶数
	
	
　
算法的时间复杂度
	1、定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。 
		也就是说时间复杂度是个根据代码算出来的.
	2、分类
		常数阶O(1)
		线性阶O(n)
	
树

1、节点类型
	父节点、子节点、兄弟节点、根节点、叶子节点
	根节点的判断依据:如果一个节点没有父节点,那么这个节点就是整棵树的跟节点。
	叶子节点：这个节点没有任何子节点,那么这个节点就是叶子节点
	单个节点也是树
	树的定义：由根节点和若干子树构成
2、相关概念
	节点的度:一个节点拥有的子树的个数
	树的度:树的度就是最大的节点的度
	节点的层次:根节点在第一层,一棵树的深度就是树中节点所在的最大层数(也就是节点的层数)。
	有序树和无序树：
3、树的表示方法
	最常用的表示方法是使用广义表的方式。图 1（A）用广义表表示为：
		(A , ( B ( E ( K , L ) , F ) , C ( G ) , D ( H ( M ) , I , J ) ) )
4、满二叉树、完全二叉树

	type Tree struct{

		left *Tree
		right *Tree
		data interface{}
	}
5、二叉树的遍历(遍历的顺序取决于跟几点的位置)
	前序遍历(先序遍历)：根--->左子树--->右子树
	中序遍历：左子树--->根--->右子树
	后续遍历：右子树--->左子树--->根
	对于二叉树的操作,它和递归就是仅仅关联在一起的,包括添加、删除一个节点、获取最值和全部数据。
	递归思想的底层实现,实际上是栈的数据结构,所以，对于二叉树遍历的操作也可以使用非递归的算法实现。
6、二叉树
	6.1、二叉树的基本形态:(从无到到有)
		空二叉树
		只有一个根节点
		根节点只有左子树
		根节点只有右子树
		根节点既有左子树又有右子树
	6.2、特殊二叉树
		斜树：
			左斜树:所有节点都只有左子树的二叉树叫左斜树
			右斜树:所有节点都只有右子树的二叉树叫右斜树
			斜树特点：每一层都只有一个节点,节点个数与二叉树的深度相同
			线性表也可以理解为树的一种及其特殊的表现形式
		满二叉树:
			在一棵二叉树中,如果所有分支节点都存在左子树和右字树,并且所有叶子都在同一层上,这样的二叉树称为满二叉树
		完全二叉树
			对于一课具有n个节点的二叉树按层序编号,如果编号为i的(1<=i<=n)的节点与
		同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同,则这课二叉树称为完全二叉树。
		(简单地说,就是看这个节点的位置是否发生变化)
		完全二叉树的特点：
			叶子节点只能出现在最下面的两层
			最下层的叶子一定集中在左部连续位置
			倒数二亮,若有叶子节点,一定都有右部连续位置
			如果节点的度为1,则该节点只有左孩子,即不存在只有右子树的情况
			同样节点数的二叉树,完全二叉树的深度最小
		如何判断二叉树是否是完全二叉树
			按照二叉树的结构逐层顺序编号,如果编号出现空挡,那就不是完全二叉树。
		二叉树有以下几个性质：TODO(上标和下标)
			性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)。
			性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)。
			性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。
			性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。
		二叉树的存储结构
			顺序存储结构
				忽略了节点之间的关系,因为二叉树的顺序都是已经排好的，在存储的时候，按照层次的顺序，
				一个节点一个顺序添加到数组中。
			二叉链表
				就是用链表来存储。
				type BinaryTree struct{
					data 	interface{}  //数据域
					left 	*BinaryTree	 //左孩子
					right  	*BinaryTree	 //右孩子
					parent 	*BinaryTree  // 当前节点的父节点
				}
		二叉树的遍历:是指从各节点出发,按照某种次数依次访问二叉树中所有节点,使得每个节点被访问依次且仅被访问一次。
		二叉树的定义是用递归的方式
				A
			B	C	D
		
		树转换为二叉树
			1、加线
				将所有兄弟节点之间加一条连线
			2、去线
				对树中的每个节点,只保留它与第一个孩子结点的连线,删除它与其他孩子结点之案件的连线。
			3、层次调整
				以树的根节点为轴心,将整棵树顺时针旋转一定的角度,使之层次分明
				这个时候就是注意层次关系（到时候转换的时候，c就是b的右子树）
		森林转换为二叉树
			1、把每棵树转换为二叉树
			2、第一棵二叉树不懂，从第二棵二叉树开始，依次把后一棵二叉树的根节点作为前一棵二叉树的根节点的右孩子，用线连起来。
			当所有的二叉树链接起来后，就得到了由森林转换来的二叉树。
		二叉树转换为树
			就是“树转换为二叉树”的逆过程。
			二叉树的左孩子都是其父节点的子节点
			二叉树的右孩子都是其父节点的兄弟节点
		二叉树转换为森林
			判断一棵二叉树能转换为一棵树还是森林，就是看这棵二叉树的根节点有没有右孩子。有就是森林。
		步骤：
			1、从根节点开始，看到右孩子，就把与右孩子的连线删除。然后得到分离的二叉树。
			2、将每棵分离后的二叉树转换为树就好了。
赫尔夫曼树	
	1、定义：
		也叫最有二叉树,指的是带权路径长度最小的二叉树。
	2、如何构造(也就是将权重按照由小到大的顺序一次排列,然后依次取两个来构造最小二叉树。)
构建过程分四步：
1. 根据给定的n个权值{w1, w2, w3 ... wn }构成n棵二叉树的集合F={T1,T2,T3,T4}， 每棵二叉树Ti都只包含一个结点,其左右子树均为空。
2. 在上面的二叉树中选出两颗根结点权值最小的树， 同时另外取一个新的结点作为这两颗树的根结点， 设新节点的权值为两颗权值最小的树的权值和， 将得到的这颗树也加入到树的集合中
3. 在2操作后， 从集合中删除权值最小的那两颗树
4. 重复2和3，直到集合中的树只剩下一棵为止， 剩下的这颗树就是我们要求得的赫夫曼树。	
	
数组

1、数组和线性表的关系
	
	数组：数组作为一种数据类型，作用是将类型相同的数据存储在一整块内存中，
		 数组中存储的数据之间没有任何逻辑关系，谁也不认识谁。
	顺序表:作为线性表的存储结构，存储的这些数据元素在物理存储结构上相邻的同时，
	在逻辑结构上也相邻，每个数据元素都清楚地知道紧挨着它的前边的元素和后边的元素。
		关系:数组来存储的线性表是顺序表。
	1.2、数组的顺序存储结构
		数组在存储时有两种存储方式：
			以列序为主(先列后行)
			以行序为主(先行后列)
	1.3、数组中调取数据元素的方式
		在n维数组中调取数据元素,需要知道一下几个因素:
		1、数组的起始位置
		2、被调取元素的具体位置
		3、数组中单个数据元素占用的内存空间
2、矩阵

对称矩阵：如果n阶矩阵中的元素满足： aij=aji(i为行标,j为列标)，就称这个矩阵为对称矩阵。

	若将对称矩阵压缩存储在一维数组 S[k] 中，矩阵中数据元素在数组中存储的位置和所在的行标（用 i 表示）和列标（用 j 表示）有关。
	存储下三角区域的数据元素：
		k=i*(i-1)/2+j-1
	存储卡上三角区域的数据元素:
		k=j*(j-1)/2+i-1
上下三角矩阵
	上三角矩阵是指主对角线下方的元素（不包括主对角线上的）都是常数C（包括数值 0 ）
	下三角矩阵是指主对角线上方的元素都是常数C。
稀疏矩阵
	矩阵中只含有少量的非 0 元素
	
矩阵压缩存储的方式
矩阵压缩存储的方式有 3 种，分别为：三元组顺序表、行逻辑链接的顺序表和十字链表。	
	
	
	
	
type Node struct{
	data interface{}
	next *Node
	
}

type Stack struct{
	
	top *Node // 头指针
	count int // 堆栈的长度
}

栈
	1、定义：栈是线性表的一种特殊结构,只能从表的固定一端对数据进行插入和删除操作。
		在栈中可以对其操作的那一端称为"栈顶",被封死的那一端称为“栈底”
	2、栈中操作元素的方式：入栈和出栈
	3、栈的溢出
		上溢：在栈已经存满数据的情况下,如果继续向栈中存入数据,栈存储就会出错
		下溢：在栈内为空的情况下,如果继续对栈进行取数据操作,就会出错。
	4、分类
		顺序栈：底层用数组来实现
		链栈：用链表来实现
			链栈一般不需要创建头结点,头结点会增加程序的复杂性,只需要一个头指针就可以了
	
队列：
	1、队列是线性表的一种，在操作元素的时候，有自己的规则。使用队列存取数据元素时,数据元素只能从表的一端进入队列,则称进入队列的一端为“队尾”
		出队列的一端为“对头”。队列符合先进先出的规则,也就是陆陆续续从队列尾部进入，然后从队首出去。
	2、存储分类
		顺序存储(数组)和链式存储(链表)
	3、链式存储实现
		包括两个指针域和一个数据域
		type queue struct{
			head *node // 头指针
			tail *node // 尾指针
			count int  // 队列中元素的数量
		}
		
		type node struct{
			data interface{} // 保存当前节点的数据
			next *node // 指向下一个节点
		}
	4、使用队列应该注意：避免“野指针”的出现
		当队列中最后一个数据元素被删除时,不能认为和尾指针没有任何关系。
		如果这是个队列只有一个元素,当它被删除的时候,尾指针指向的内存空间已经被释放,这时候需要对尾指针进行重新定义。
		




线性表特点：
	1、存储的数据结构相同
	2、各个元素的相对位置已经固定(相对位置:也就是各个数据元素在逻辑结构上的前后顺序)
	3、分类：
		顺序结构：数据元素在内存中集中存储,采用顺序表示结构
		链式结构：数据元素在内存中散列存储,采用链式表示结构
		
		
		顺序结构：数组、切片。
		链式结构:map、自己设计的数据结构：比如程序中用到的队列。

		顺序表的实现使用的数组。顺序表查询快、增删慢
	
	线性表在存取数据的时候,时间复杂度都是O(1)，在插入插入时,时间复杂度都是O(n)
	
	4、链表
		4.1、线性表的链式存储结构生成的表称作"链表"
		4.2、链表中数据元素(节点)的构成
			数据域：这个节点包含的信息
			指针域：指向下一个节点的指针
		4.3、链表分类
			单向链表、双向链表
		4.4、链表的几个小概念吧
			头结点：
			首元节点：链表中第一个元素所在的位置，它是头结点后边的第一个节点
			头指针：永远指向链表中第一个节点的位置
		4.5、对链表进行操作
			node1--->node2--->node3--->node4
			插入节点
				向链表插入新节点在(node2和node3之间)新节点node5
					node5保存node3的地址(将保存在node2中下一个节点的位置给node5)
					node2保存node5的地址(取出node2节点的位置,然后把它赋值给node2)
			删除节点
				比如现在删除node3
					(将node3节点的位置临时备份一下)
					node2保存node4节点的位置(将保存在node3中node4节点的位置赋值给node2)
					去掉node3
		4.6、线性表和链性表的比较
			链式存储添加或者删除一个元素很容易，但是查询慢
			线性存储查询快，增删慢
	5、静态链表
			静态链表使用数组这一个数据类型预先申请足够大的内存空间。
		5.1、逻辑结构上相邻的数据元素，存储在制定的一块内存空间中,数据元素值允许在这块内存空间中随机存放，这样的存储结构就是静态链表。
		5.2、静态链表和动态链表的区别
			静态链表限制了数据元素存放的位置范围
			动态链表是整个内存空间
		5.3、静态链表的空间重复利用
			在静态链表中，提前将所有未使用的节点链成一个备用链表。在需要对链表进行操作时,从备用链表中拿过来一个节点使用。
			在删除节点时,删除的同时链接到备用链表上(也就是把删除节点的信息添加到备用链表上)
		5.4、链表中节点的构成
			数据域和游标(游标：存放的是下一个节点在数组中的位置下标)
		5.5、静态链表的特点
			静态链表综合了顺序链表和动态链表的有点：使用数组来存储数据元素,便于做查找遍历操作。
			同时在数中节点了动态链表的特点，在链表中插入或者删除节点时只需要更改相关节点的游标，不需要移动大量元素。
		缺点：没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性。
	
就是把所有未被使用过的及已经被删除的分量用游标链成一个备用的链表，这样，每当插入的时候,
便可以从备用链表上取得第一个节点作为待插入的新节点。

静态数组的第一个元素和最后一个元素需要做特殊处理。

静态数组的说明：
	第一个元素用来存放备用链表的第一个节点的下标
	最后一个元素用来存放第一个有数值的元素的下标(也就是相当于单链表中的头结点的作用吧)
静态数组的 插入/删除 元素：
 	插入元素也就是更改之前数组中存放下一个元素位置的索引值的问题。

			线性表
顺序存储结构			链式存储结构
					单链表、静态链表、循环链表、双向链表


	6、双向链表
		6.1、双向链表：在单向链表的基础上,给每个节点额外配备一个指针变量,用于指向每隔节点的直接前驱节点,这就是双向链表
		6.2、双向链表的构成
			双向链表中有两个指针域和一个数据域。一个指向直接前趋，之歌指向直接后继。
		链表中第一个节点的前趋节点为nil,最后一个节点的后继节点为nil。
		
		双向链表和单向链表相比，就是多了一个指向上一个元素的指针。
		
递归函数：把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数,成为递归函数。

队首指针：front
对尾指针:rear
通用的计算队列长度公式为:(rear-front+QueueSize)%QueueSize
队列满的条件:(rear+1)%QueueSize==front
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			