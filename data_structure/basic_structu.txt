## 数据结构的学习
## 2018.3.6

一、学习网址
	1、严长生
		http://data.bianchegn.net/view/8.html
		http://data.biancheng.net/view/13.html

树

1、节点类型
	父节点、子节点、兄弟节点、根节点、叶子节点
	根节点的判断依据:如果一个节点没有父节点,那么这个节点就是整棵树的跟节点。
	叶子节点：这个节点没有任何子节点,那么这个节点就是叶子节点
	单个节点也是树
	树的定义：由根节点和若干子树构成
2、相关概念
	节点的度:一个节点拥有的子树的个数
	树的度:树的度就是最大的节点的度
	节点的层次:根节点在第一层,一棵树的深度就是树中节点所在的最大层数(也就是节点的层数)。
	有序树和无序树：
3、树的表示方法
	最常用的表示方法是使用广义表的方式。图 1（A）用广义表表示为：
		(A , ( B ( E ( K , L ) , F ) , C ( G ) , D ( H ( M ) , I , J ) ) )
4、满二叉树、完全二叉树


type Tree struct{

	left *Tree
	right *Tree
	data interface{}
}


	
数组

1、数组和线性表的关系
	
	数组：数组作为一种数据类型，作用是将类型相同的数据存储在一整块内存中，
		 数组中存储的数据之间没有任何逻辑关系，谁也不认识谁。
	顺序表:作为线性表的存储结构，存储的这些数据元素在物理存储结构上相邻的同时，
	在逻辑结构上也相邻，每个数据元素都清楚地知道紧挨着它的前边的元素和后边的元素。
		关系:数组来存储的线性表是顺序表。
	1.2、数组的顺序存储结构
		数组在存储时有两种存储方式：
			以列序为主(先列后行)
			以行序为主(先行后列)
	1.3、数组中调取数据元素的方式
		在n维数组中调取数据元素,需要知道一下几个因素:
		1、数组的起始位置
		2、被调取元素的具体位置
		3、数组中单个数据元素占用的内存空间
2、矩阵

对称矩阵：如果n阶矩阵中的元素满足： aij=aji(i为行标,j为列标)，就称这个矩阵为对称矩阵。

	若将对称矩阵压缩存储在一维数组 S[k] 中，矩阵中数据元素在数组中存储的位置和所在的行标（用 i 表示）和列标（用 j 表示）有关。
	存储下三角区域的数据元素：
		k=i*(i-1)/2+j-1
	存储卡上三角区域的数据元素:
		k=j*(j-1)/2+i-1
上下三角矩阵
	上三角矩阵是指主对角线下方的元素（不包括主对角线上的）都是常数C（包括数值 0 ）
	下三角矩阵是指主对角线上方的元素都是常数C。
稀疏矩阵
	矩阵中只含有少量的非 0 元素
	
矩阵压缩存储的方式
矩阵压缩存储的方式有 3 种，分别为：三元组顺序表、行逻辑链接的顺序表和十字链表。	
	
	
	
	
type Node struct{
	data interface{}
	next *Node
	
}

type Stack struct{
	
	top *Node // 头指针
	count int // 堆栈的长度
}

栈
	1、定义：栈是线性表的一种特殊结构,只能从表的固定一端对数据进行插入和删除操作。
		在栈中可以对其操作的那一端称为"栈顶",被封死的那一端称为“栈底”
	2、栈中操作元素的方式：入栈和出栈
	3、栈的溢出
		上溢：在栈已经存满数据的情况下,如果继续向栈中存入数据,栈存储就会出错
		下溢：在栈内为空的情况下,如果继续对栈进行取数据操作,就会出错。
	4、分类
		顺序栈：底层用数组来实现
		链栈：用链表来实现
			链栈一般不需要创建头结点,头结点会增加程序的复杂性,只需要一个头指针就可以了
	
队列：
	1、队列是线性表的一种，在操作元素的时候，有自己的规则。使用队列存取数据元素时,数据元素只能从表的一端进入队列,则称进入队列的一端为“队尾”
		出队列的一端为“对头”。队列符合先进先出的规则,也就是陆陆续续从队列尾部进入，然后从队首出去。
	2、存储分类
		顺序存储(数组)和链式存储(链表)
	3、链式存储实现
		包括两个指针域和一个数据域
		type queue struct{
			head *node // 头指针
			tail *node // 尾指针
			count int  // 队列中元素的数量
		}
		
		type node struct{
			data interface{} // 保存当前节点的数据
			next *node // 指向下一个节点
		}
	4、使用队列应该注意：避免“野指针”的出现
		当队列中最后一个数据元素被删除时,不能认为和尾指针没有任何关系。
		如果这是个队列只有一个元素,当它被删除的时候,尾指针指向的内存空间已经被释放,这时候需要对尾指针进行重新定义。
		




线性表特点：
	1、存储的数据结构相同
	2、各个元素的相对位置已经固定(相对位置:也就是各个数据元素在逻辑结构上的前后顺序)
	3、分类：
		顺序结构：数据元素在内存中集中存储,采用顺序表示结构
		链式结构：数据元素在内存中散列存储,采用链式表示结构
		
		
		顺序结构：数组、切片。
		链式结构:map、自己设计的数据结构：比如程序中用到的队列。

		顺序表的实现使用的数组。顺序表查询快、增删慢
	4、链表
		4.1、线性表的链式存储结构生成的表称作"链表"
		4.2、链表中数据元素(节点)的构成
			数据域：这个节点包含的信息
			指针域：指向下一个节点的指针
		4.3、链表分类
			单向链表、双向链表
		4.4、链表的几个小概念吧
			头结点：
			首元节点：链表中第一个元素所在的位置，它是头结点后边的第一个节点
			头指针：永远指向链表中第一个节点的位置
		4.5、对链表进行操作
			node1--->node2--->node3--->node4
			插入节点
				向链表插入新节点在(node2和node3之间)新节点node5
					node5保存node3的地址(将保存在node2中下一个节点的位置给node5)
					node2保存node5的地址(取出node2节点的位置,然后把它赋值给node2)
			删除节点
				比如现在删除node3
					(将node3节点的位置临时备份一下)
					node2保存node4节点的位置(将保存在node3中node4节点的位置赋值给node2)
					去掉node3
		4.6、线性表和链性表的比较
			链式存储添加或者删除一个元素很容易，但是查询慢
			线性存储查询快，增删慢
	5、静态链表
			静态链表使用数组这一个数据类型预先申请足够大的内存空间。
		5.1、逻辑结构上相邻的数据元素，存储在制定的一块内存空间中,数据元素值允许在这块内存空间中随机存放，这样的存储结构就是静态链表。
		5.2、静态链表和动态链表的区别
			静态链表限制了数据元素存放的位置范围
			动态链表是整个内存空间
		5.3、静态链表的空间重复利用
			在静态链表中，提前将所有未使用的节点链成一个备用链表。在需要对链表进行操作时,从备用链表中拿过来一个节点使用。
			在删除节点时,删除的同时链接到备用链表上(也就是把删除节点的信息添加到备用链表上)
		5.4、链表中节点的构成
			数据域和游标(游标：存放的是下一个节点在数组中的位置下标)
		5.5、静态链表的特点
			静态链表综合了顺序链表和动态链表的有点：使用数组来存储数据元素,便于做查找遍历操作。
			同时在数中节点了动态链表的特点，在链表中插入或者删除节点时只需要更改相关节点的游标，不需要移动大量元素。
	6、双向链表
		6.1、双向链表：在单向链表的基础上,给每个节点额外配备一个指针变量,用于指向每隔节点的直接前驱节点,这就是双向链表
		6.2、双向链表的构成
			双向链表中有两个指针域和一个数据域。一个指向直接前趋，之歌指向直接后继。
		链表中第一个节点的前趋节点为nil,最后一个节点的后继节点为nil。
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			